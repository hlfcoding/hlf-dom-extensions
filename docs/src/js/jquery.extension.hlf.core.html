<!DOCTYPE html><html lang="en"><head><title>src/js/jquery.extension.hlf.core</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../../"><meta name="groc-document-path" content="src/js/jquery.extension.hlf.core"><meta name="groc-project-path" content="src/js/jquery.extension.hlf.core.coffee"><link rel="stylesheet" type="text/css" media="all" href="../../assets/style.css"><script type="text/javascript" src="../../assets/behavior.js"></script><body><div id="meta"><div class="file-path">src/js/jquery.extension.hlf.core.coffee</div></div><div id="document"><div class="segment"><div class="comments "><div class="wrapper"><h1 id="hlf-core-jquery-extension">HLF Core jQuery Extension</h1></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><a href="../../tests/js/core.html">Tests</a> | <a href="../../tests/js/core.plugin.html">Plugin Tests</a> | <a href="../../tests/js/core.mixin.html">Mixin Tests</a> </p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The core extension is comprised of several aspects.</p>
<ul>
<li><p>Mixin creation and manipulation, as well as providing base mixins, via:
<code>$.applyMixin</code>, <code>$.applyMixins</code>, <code>$.createMixins</code>, <code>$.mixins</code>.</p>
</li>
<li><p>Plugin creation with support for both classes and mixins, via: 
<code>$.createPlugin</code>.</p>
</li>
<li><p>Integrated no-conflict handling and debug-logging, via: <code>$.hlf.noConflict</code>, 
<code>$.hlf.debugLog</code>. Child namespaces (for plugins, etc.) automatically inherit
these methods unless they provide their own.</p>
</li>
</ul>
<p>The extension also creates and provides the <code>hlf</code> jQuery namespace. Namespaces
for other extensions and plugins are attached to this main namespace.</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>ยง <strong>UMD</strong></p>
<ul>
<li>When AMD, register the attacher as an anonymous module.</li>
<li>When Node or Browserify, set module exports to the attach result.</li>
<li>When browser globals (root is window), Just run the attach function.</li>
</ul></div></div><div class="code"><div class="wrapper">(<span class="hljs-function"><span class="hljs-params">(root, attach)</span> -&gt;</span>
  <span class="hljs-keyword">if</span> <span class="hljs-keyword">typeof</span> define <span class="hljs-keyword">is</span> <span class="hljs-string">'function'</span> <span class="hljs-keyword">and</span> define.amd?
    define [
      <span class="hljs-string">'jquery'</span>
      <span class="hljs-string">'underscore'</span>
    ], attach
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">typeof</span> exports <span class="hljs-keyword">is</span> <span class="hljs-string">'object'</span>
    <span class="hljs-built_in">module</span>.exports = attach(
      <span class="hljs-built_in">require</span> <span class="hljs-string">'jquery'</span>,
      <span class="hljs-built_in">require</span> <span class="hljs-string">'underscore'</span>
    )
  <span class="hljs-keyword">else</span>
    attach jQuery, _
)(@, <span class="hljs-function"><span class="hljs-params">($, _)</span> -&gt;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="namespace">Namespace</h2></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>It takes some more boilerplate and helpers to write jQuery modules. That
code and set of conventions is here in the root namespace <strong>$.hlf</strong>. Child
namespaces follow suit convention.</p>
<ul>
<li><p>The <strong>debug</strong> flag here toggles debug logging for everything in the library
that doesn&#39;t have a custom debug flag in its namespace.</p>
</li>
<li><p><strong>toString</strong> is mainly for namespacing when extending any jQuery API. For
now, its base form is very simple.</p>
</li>
<li><p><strong>noConflict</strong> in its base form will remove assignments to the global
jQuery namespace. Properties will have to be accessed through the <code>$.hlf</code>
namespace. See <code>_safeSet</code> below. Also see <code>createPlugin</code> for its no-
conflict integration.</p>
<p>Using <code>_noConflicts</code>, we keep track of no-conflict procedures. This is
essentially working with a callback queue. Calling <code>$.hlf.noConflict</code>
simply runs these procedures. Procedures should be simple and idempotent,
ie. restoring the property to a saved previous value.</p>
</li>
<li><p><strong>debugLog</strong> in its base form just wraps around <code>console.log</code> and links to
the <code>debug</code> flag. However, <code>debugLog</code> conventionally becomes a no-op if
the <code>debug</code> flag is off.</p>
</li>
</ul></div></div><div class="code"><div class="wrapper">  hlf =
    <span class="hljs-attribute">debug</span>: <span class="hljs-literal">on</span> <span class="hljs-comment"># Turn this off when going to production.</span>
    <span class="hljs-attribute">toString</span>: _.constant <span class="hljs-string">'hlf'</span>
    <span class="hljs-attribute">noConflict</span>: <span class="hljs-function">-&gt;</span> (fn() <span class="hljs-keyword">for</span> fn <span class="hljs-keyword">in</span> _noConflicts).length

  hlf.debugLog = <span class="hljs-keyword">if</span> hlf.debug <span class="hljs-keyword">is</span> <span class="hljs-literal">off</span> <span class="hljs-keyword">then</span> $.noop <span class="hljs-keyword">else</span>
    (<span class="hljs-keyword">if</span> <span class="hljs-built_in">console</span>.log.bind <span class="hljs-keyword">then</span> <span class="hljs-built_in">console</span>.log.bind(<span class="hljs-built_in">console</span>) <span class="hljs-keyword">else</span> <span class="hljs-built_in">console</span>.log)

  _noConflicts = []
  </div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="plugin-support">Plugin Support</h2></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Plugin generation is perhaps the most common jQuery boilerplate. Further
binding state and functionality to jQuery elements is a common task that
should be abstracted away, with common patterns and conventions around
logging, jQuery namespacing, instance access, and sending commands. Also,
instead of API classes and plugins inheriting from a base layer, that base
layer should be integrated on instantiation.</p></div></div><div class="code"><div class="wrapper">  _.extend hlf,</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>createPlugin</strong> will return an appropriate jQuery plugin method for the
given <code>createOptions</code>, comprised of:</p>
<ul>
<li><p>The <strong>name</strong> of the method is required. The <code>safeName</code> for the method,
which needs to be on the jQuery prototype, is prefixed by <code>hlf</code> and
should be used after <code>noConflict</code> is called.</p>
</li>
<li><p><strong>namespace</strong> is required and must correctly implement <code>debug</code>,
<code>toString</code>, and <code>defaults</code>. It can optionally have a <code>noConflict</code>
procedure.</p>
</li>
<li><p>An <strong>apiClass</strong> definition and/or an <strong>apiMixins</strong> collection. It will
get modified with base API additions. A <code>mixinFilter</code> can be provided to
limit the mixins in the collection that get applied during instantiation.
If provided, the <code>apiMixins</code> collection must have a <code>base</code> mixin, which
will get the <code>apiAdditions</code>. Also note that <code>apiClass</code> and <code>apiMixins</code>
will get published into the namespace, so additional flexibility is
possible, especially with non-specific mixins.</p>
</li>
<li><p>The plugin&#39;s <strong>noConflict</strong> procedure, which gets published onto its
namespace, but default just restores to the previous method. If a
<code>noConflict</code> procedure is provided by the namespace, it gets run
beforehand as well.</p>
</li>
</ul></div></div><div class="code"><div class="wrapper">    <span class="hljs-attribute">createPlugin</span>: <span class="hljs-function"><span class="hljs-params">(createOptions)</span> -&gt;</span>
      name = createOptions.name
      safeName = <span class="hljs-string">"<span class="hljs-subst">#{<span class="hljs-property">@toString</span>()}</span><span class="hljs-subst">#{name[<span class="hljs-number">0</span>].toUpperCase()}</span><span class="hljs-subst">#{name[<span class="hljs-number">1.</span>.]}</span>"</span>
      namespace = createOptions.namespace

      apiAdditions = _createPluginAPIAdditions name, namespace
      <span class="hljs-keyword">if</span> createOptions.apiClass?
        apiClass = namespace.apiClass = createOptions.apiClass
        _.extend <span class="hljs-attribute">apiClass</span>::, apiAdditions
      <span class="hljs-keyword">if</span> createOptions.apiMixins?
        mixinFilter = createOptions.mixinFilter
        mixinFilter ?= <span class="hljs-function"><span class="hljs-params">(mixin)</span> -&gt;</span> mixin
        apiMixins = namespace.apiMixins = createOptions.apiMixins
        $.extend (deep = <span class="hljs-literal">on</span>), apiMixins, { <span class="hljs-attribute">base</span>: apiAdditions }

      _noConflict = namespace.noConflict
      _plugin = $.fn[name]
      _noConflicts.push (namespace.noConflict = <span class="hljs-function">-&gt;</span>
        <span class="hljs-keyword">if</span> _.isFunction(_noConflict) <span class="hljs-keyword">then</span> _noConflict()
        $.fn[name] = _plugin
      )</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>ยง <strong>Plugin Method</strong></p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The <strong>plugin</strong> method handles two variations of input. A command <code>type</code>
(name) and <code>userInfo</code> can be passed in to trigger the command route. The
latter is typically additional, command-specific parameters. Otherwise,
if the first argument is an options collection, the normal route is
triggered.</p>
<p>With the command route, if there is a plugin instance and it can
<strong>handleCommand</strong>, call the method, but invoke <code>userInfo</code> if needed
beforehand. With the normal route, if there is a plugin instance and no 
arguments are provided we assume the call is to access the instance,
not reset it.</p>
<p>Otherwise if the instance exists, it is returned. <strong>asSharedInstance</strong>
will decide what the plugin instance&#39;s main element will be. The idea is
several elements all share the same plugin instance.</p>
<p>Otherwise, continue creating the instance by preparing the options and
deciding the main element before passing over to <code>_createPluginInstance</code>.</p></div></div><div class="code"><div class="wrapper">      plugin = $.fn[name] = $.fn[safeName] = <span class="hljs-function">-&gt;</span>
        <span class="hljs-keyword">if</span> _.isString(arguments[<span class="hljs-number">0</span>])
          command =
            <span class="hljs-attribute">type</span>: arguments[<span class="hljs-number">0</span>]
            <span class="hljs-attribute">userInfo</span>: arguments[<span class="hljs-number">1</span>]
        <span class="hljs-keyword">else</span>
          options = arguments[<span class="hljs-number">0</span>]
          $context = arguments[<span class="hljs-number">1</span>] <span class="hljs-keyword">if</span> arguments[<span class="hljs-number">1</span>]?
        <span class="hljs-comment">#- The element's `$context` will default to document body.</span>
        $context ?= $ <span class="hljs-string">'body'</span>

        <span class="hljs-keyword">if</span> command?
          <span class="hljs-property">@each</span> -&gt;
            $el = $(@)
            instance = $el.data namespace.toString(<span class="hljs-string">'data'</span>)
            <span class="hljs-keyword">if</span> _.isFunction(instance.handleCommand)
              <span class="hljs-keyword">if</span> _.isFunction(command.userInfo) <span class="hljs-keyword">then</span> command.userInfo $el
              sender = <span class="hljs-literal">null</span>
              instance.handleCommand command, sender
          <span class="hljs-keyword">return</span> @ <span class="hljs-comment"># Follow plugin return conventions.</span>

        <span class="hljs-keyword">else</span>
          $el = <span class="hljs-keyword">if</span> createOptions.asSharedInstance <span class="hljs-keyword">is</span> <span class="hljs-literal">yes</span> <span class="hljs-keyword">then</span> $context <span class="hljs-keyword">else</span> <span class="hljs-property">@first</span>()
          instance = $el.data namespace.toString(<span class="hljs-string">'data'</span>)
          <span class="hljs-keyword">return</span> instance <span class="hljs-keyword">if</span> instance? <span class="hljs-keyword">and</span> instance.$el? <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> options?

        options = $.extend (deep = <span class="hljs-literal">on</span>), {}, namespace.defaults, options
        $el = @
        ( <span class="hljs-function">-&gt;</span>
          args = arguments
          <span class="hljs-keyword">if</span> createOptions.asSharedInstance <span class="hljs-keyword">is</span> <span class="hljs-literal">yes</span> <span class="hljs-keyword">then</span> _createPluginInstance $el, args...
          <span class="hljs-keyword">else</span> $el.each -&gt; _createPluginInstance $(@), args...
        )(options, $context, namespace, apiClass, apiMixins, mixinFilter, createOptions)
        <span class="hljs-keyword">return</span> @ <span class="hljs-comment"># Follow plugin return conventions.</span>

  _.bindAll hlf, <span class="hljs-string">'createPlugin'</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>_createPluginInstance</strong> is a private subroutine that&#39;s part of
<code>createPlugin</code>, which has more details on its required input.</p>
<ol>
<li><p>Check if plugin element has options set in its plugin data attribute. If
so, merge those options into our own <code>finalOptions</code>.</p>
</li>
<li><p>Also decide the <code>$root</code> element based on the situation. It&#39;s where the
plugin instance gets stored and the root plugin class gets added.
A shared instance, for example, gets stored on the <code>$context</code>.</p>
</li>
<li><p>If we&#39;re provided with a class for the API, instantiate it. Decorate the
instance with additional mixins if applicable.</p>
</li>
<li><p>If instead we&#39;re provided with just mixins for the API, create a plain
object with the base properties for the instance. Then apply the provided
mixins in order: the names of the base mixins, the <code>base</code> mixin from the
provided mixins collection, and the <code>otherMixins</code>. The others are just
mixins allowed by the provided filter (if any) that also aren&#39;t <code>base</code>.</p>
</li>
<li><p>If the <code>compactOptions</code> flag is toggled, <code>finalOptions</code> will be merged
into the instance. This makes accessing options more convenient, but can
cause conflicts with larger existing APIs that don&#39;t account for such
naming conflicts, since <em>we don&#39;t handle conflicts here</em>. Otherwise, just
alias the conventional <code>selectors</code> and <code>classNames</code> option groups.</p>
</li>
<li><p>If the <code>autoSelect</code> flag is toggled and a <code>select</code> method is provided
(ie. via <code>selection</code> mixin), call it and automatically setup element
references prior to initialization.</p>
</li>
<li><p>If the <code>cls</code> API addition exists and provides the root class, add the root
class to the decided <code>$root</code> prior to initialization.</p>
</li>
<li><p>If an <code>init</code> method is provided, and one must be if it&#39;s just mixins for
the API, call it. Convention is to always provide it.</p>
</li>
<li><p>Lastly, store the instance on <code>$root</code>.</p>
</li>
</ol></div></div><div class="code"><div class="wrapper"><span class="hljs-function">  <span class="hljs-title">_createPluginInstance</span> = <span class="hljs-params">($el, options, $context, namespace, apiClass, apiMixins, mixinFilter, createOptions)</span> -&gt;</span>
    data = $el.data namespace.toString(<span class="hljs-string">'data'</span>)
    finalOptions = options

    <span class="hljs-keyword">if</span> $.isPlainObject(data)
      finalOptions = $.extend (deep = <span class="hljs-literal">on</span>), {}, options, data
      $root = $el
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> createOptions.asSharedInstance
      $root = $context
    <span class="hljs-keyword">else</span>
      $root = $el

    <span class="hljs-keyword">if</span> apiClass?
      instance = <span class="hljs-keyword">new</span> apiClass $el, finalOptions, $context
      <span class="hljs-keyword">if</span> createOptions.baseMixins?
        hlf.applyMixins instance, namespace, createOptions.baseMixins...
      <span class="hljs-keyword">if</span> createOptions.apiMixins?
        hlf.applyMixins instance, namespace, createOptions.apiMixins...

    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> apiMixins?
      instance = { $el, <span class="hljs-attribute">options</span>: finalOptions }
      <span class="hljs-keyword">if</span> createOptions.baseMixins?
        hlf.applyMixins instance, namespace, createOptions.baseMixins...
      hlf.applyMixin instance, namespace, apiMixins.base
      otherMixins = _.chain apiMixins
        .filter mixinFilter, instance
        .values()
        .without apiMixins.base
        .value()
      hlf.applyMixins instance, namespace, otherMixins...

    <span class="hljs-keyword">if</span> createOptions.compactOptions <span class="hljs-keyword">is</span> <span class="hljs-literal">yes</span>
      $.extend (deep = <span class="hljs-literal">yes</span>), instance, finalOptions
      <span class="hljs-keyword">delete</span> instance.options
    <span class="hljs-keyword">else</span>
      <span class="hljs-keyword">if</span> finalOptions.selectors? <span class="hljs-keyword">then</span> instance.selectors = finalOptions.selectors
      <span class="hljs-keyword">if</span> finalOptions.classNames? <span class="hljs-keyword">then</span> instance.classNames = finalOptions.classNames

    <span class="hljs-keyword">if</span> createOptions.autoSelect <span class="hljs-keyword">is</span> <span class="hljs-literal">yes</span> <span class="hljs-keyword">and</span> _.isFunction(instance.select)
      instance.select()

    <span class="hljs-keyword">if</span> instance.cls <span class="hljs-keyword">isnt</span> $.noop <span class="hljs-keyword">then</span> $root.addClass instance.cls()

    <span class="hljs-keyword">if</span> _.isFunction(instance.init) <span class="hljs-keyword">then</span> instance.init()
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> apiClass? <span class="hljs-keyword">then</span> hlf.debugLog <span class="hljs-string">'ERROR: No `init` method on instance.'</span>, instance

    $root.data instance.attr(), instance
    <span class="hljs-keyword">return</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>_createPluginAPIAdditions</strong> is a private subroutine that&#39;s part of
<code>createPlugin</code>, which has more details on its required input.</p>
<ul>
<li>Add the <strong>evt</strong> method to namespace an event name.</li>
<li>Add the <strong>attr</strong> method to namespace data keys and attribute names.</li>
<li>Add the <strong>cls</strong> method and attach functionality instead of a no-op only if
class namespacing is unique.</li>
<li>Add the <strong>debugLog</strong> method and attach functionality instead of a no-op
only if namespace <code>debug</code> is on.</li>
</ul></div></div><div class="code"><div class="wrapper"><span class="hljs-function">  <span class="hljs-title">_createPluginAPIAdditions</span> = <span class="hljs-params">(name, namespace)</span> -&gt;</span>
    <span class="hljs-attribute">evt</span>: _.memoize (name) -&gt; <span class="hljs-string">"<span class="hljs-subst">#{name}</span><span class="hljs-subst">#{namespace.toString <span class="hljs-string">'event'</span>}</span>"</span>
    <span class="hljs-attribute">attr</span>: _.memoize (name) -&gt;
      name = <span class="hljs-keyword">if</span> name? <span class="hljs-keyword">then</span> <span class="hljs-string">"-<span class="hljs-subst">#{name}</span>"</span> <span class="hljs-keyword">else</span> <span class="hljs-string">''</span>
      namespace.toString(<span class="hljs-string">'data'</span>) + name
    <span class="hljs-attribute">cls</span>: <span class="hljs-keyword">if</span> namespace.toString(<span class="hljs-string">'class'</span>) <span class="hljs-keyword">is</span> namespace.toString() <span class="hljs-keyword">then</span> $.noop <span class="hljs-keyword">else</span>
      _.memoize (name) -&gt;
        name = <span class="hljs-keyword">if</span> name? <span class="hljs-keyword">then</span> <span class="hljs-string">"-<span class="hljs-subst">#{name}</span>"</span> <span class="hljs-keyword">else</span> <span class="hljs-string">''</span>
        namespace.toString(<span class="hljs-string">'class'</span>) + name
    <span class="hljs-attribute">debugLog</span>: <span class="hljs-keyword">if</span> namespace.debug <span class="hljs-keyword">is</span> <span class="hljs-literal">off</span> <span class="hljs-keyword">then</span> $.noop <span class="hljs-keyword">else</span>
      -&gt; hlf.debugLog namespace.toString(<span class="hljs-string">'log'</span>), arguments...</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="mixin-support">Mixin Support</h2></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Mixins are another approach to encapsulating object-oriented behavior. This
set of helper functions are to fill the gap of a generic mixin system left
by jQuery&#39;s highly-specified plugin system. General mixins are also provided
to add helper methods for even more flexible extensions between mixins.</p></div></div><div class="code"><div class="wrapper">  _.extend hlf,</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>applyMixin</strong>, when given a <code>context</code> to decorate with a valid <code>mixin</code>,
runs any run-once hooks after applying a mixin copy without the hooks.
<code>context</code> is conventionally a class instance.</p>
<ol>
<li><p>If <code>mixin</code> is a string, check the general <code>$.mixins</code> for the mixin.</p>
</li>
<li><p>Get run-once methods and filter a clean mixin copy. Run-once methods
are what&#39;s specified in <code>$.mixinOnceNames</code> and implemented by the mixin.
Also get methods that are conventionally named like event handlers.</p>
</li>
<li><p>Apply mixin and call onces with explicit context. Also auto-bind
conventionally-named event handlers.</p>
</li>
</ol></div></div><div class="code"><div class="wrapper">    <span class="hljs-attribute">applyMixin</span>: <span class="hljs-function"><span class="hljs-params">(context, dependencies, mixin)</span> -&gt;</span>
      <span class="hljs-keyword">if</span> _.isString(mixin) <span class="hljs-keyword">then</span> mixin = <span class="hljs-property">@mixins</span>[mixin]
      <span class="hljs-keyword">if</span> _.isFunction(mixin) <span class="hljs-keyword">then</span> mixin = mixin dependencies
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">unless</span> mixin?
      onceMethods = []
      handlerNames = []

      <span class="hljs-keyword">for</span> own name, prop <span class="hljs-keyword">of</span> mixin <span class="hljs-keyword">when</span> _.isFunction(prop)
        <span class="hljs-keyword">if</span> name <span class="hljs-keyword">in</span> <span class="hljs-property">@mixinOnceNames</span> <span class="hljs-keyword">then</span> onceMethods.push prop
        <span class="hljs-keyword">if</span> name.indexOf(<span class="hljs-string">'handle'</span>) <span class="hljs-keyword">is</span> <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> name <span class="hljs-keyword">isnt</span> <span class="hljs-string">'handleCommand'</span>
          handlerNames.push name
      mixinToApply = _.omit mixin, <span class="hljs-property">@mixinOnceNames</span>

      _.extend context, mixinToApply
      method.call(context) <span class="hljs-keyword">for</span> method <span class="hljs-keyword">in</span> onceMethods
      <span class="hljs-keyword">if</span> handlerNames.length <span class="hljs-keyword">then</span> _.bindAll context, handlerNames...
      <span class="hljs-keyword">return</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>applyMixins</strong>, when given a <code>context</code> (class) to decorate with <code>mixins</code>,
which should be passed in order of application, calls <code>$.applyMixin</code> for
each mixin. Conventionally, this should be used instead of
<code>$.applyMixin</code>.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-attribute">applyMixins</span>: <span class="hljs-function"><span class="hljs-params">(context, dependencies, mixins...)</span> -&gt;</span>
      <span class="hljs-property">@applyMixin</span> context, dependencies, mixin <span class="hljs-keyword">for</span> mixin <span class="hljs-keyword">in</span> mixins
      <span class="hljs-keyword">return</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>createMixin</strong>, when given a collection of <code>mixins</code>, adds a new mixin with
given <code>name</code> and <code>mixin</code> method collection. Conventionally, each logical
package of software should be written as a collection of mixins, with one
named &#39;base&#39;.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-attribute">createMixin</span>: <span class="hljs-function"><span class="hljs-params">(mixins, name, mixin)</span> -&gt;</span>
      mixins ?= hlf.mixins
      <span class="hljs-keyword">return</span> <span class="hljs-literal">no</span> <span class="hljs-keyword">if</span> name <span class="hljs-keyword">of</span> mixins
      mixins[name] = mixin
      <span class="hljs-keyword">if</span> $.isPlainObject(mixin)
        (prop.mixin = name) <span class="hljs-keyword">for</span> own k, prop <span class="hljs-keyword">of</span> mixin <span class="hljs-keyword">when</span> _.isFunction(prop)
      mixin</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>ยง <strong>Supported Decorators</strong></p>
<ul>
<li><p><strong>decorate</strong> allows more complex extending of the instance. For example,
methods and properties can be removed, handlers can be added to
triggered events for more complex extending of existing methods.</p>
</li>
<li><p><strong>decorateOptions</strong> allows extending the context&#39;s options, which are
conventionally a property named <code>options</code>.</p>
</li>
</ul></div></div><div class="code"><div class="wrapper">    <span class="hljs-attribute">mixinOnceNames</span>: [
      <span class="hljs-string">'decorate'</span>
      <span class="hljs-string">'decorateOptions'</span>
    ]</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>$.mixins</strong> is the general mixin collection that&#39;s provided for writing
foundation-level jQuery mixins. Conventionally, other mixins not shared
between different logical packages do not belong here.</p>
<ul>
<li><p><strong>data</strong>, when given a context with a data-attribute-name translator
that makes a property-name follow jQuery conventions, as well as with
a property <code>$el</code>, generate a mixin that applies convenience wrappers
around the jQuery data API to simplify data API calls as much as
possible.</p>
</li>
<li><p><strong>event</strong>, when given a context with an event-name translator that makes
an event-name follow jQuery conventions, as well as with a property
<code>$el</code>, generates a mixin that applies convenience wrappers around the
jQuery custom event API to simplify event API calls as much as possible.</p>
</li>
<li><p><strong>selection</strong>, when given the context has a property <code>$el</code> and a property
<code>selectors</code>, define cached selector results for each name-selector pair.
Also provide selection helpers for common tasks.</p>
</li>
</ul></div></div><div class="code"><div class="wrapper">    <span class="hljs-attribute">mixins</span>:
      <span class="hljs-attribute">data</span>: <span class="hljs-function">-&gt;</span>
        <span class="hljs-attribute">data</span>: <span class="hljs-function">-&gt;</span>
          <span class="hljs-keyword">if</span> arguments.length
            first = arguments[<span class="hljs-number">0</span>]
            <span class="hljs-keyword">if</span> _.isString(first)
              arguments[<span class="hljs-number">0</span>] = <span class="hljs-property">@attr</span> first
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> _.isObject(first)
              pairs = {}
              (pairs[attr(k)] = v) <span class="hljs-keyword">for</span> own k, v <span class="hljs-keyword">of</span> first
              arguments[<span class="hljs-number">0</span>] = pairs
          <span class="hljs-property">@$el</span>.data.apply <span class="hljs-property">@$el</span>, arguments

      <span class="hljs-attribute">event</span>: <span class="hljs-function">-&gt;</span>
        <span class="hljs-attribute">on</span>: <span class="hljs-function"><span class="hljs-params">(name)</span> -&gt;</span>
          name = <span class="hljs-property">@evt</span> name <span class="hljs-keyword">if</span> name?
          <span class="hljs-property">@$el</span>.<span class="hljs-literal">on</span>.apply <span class="hljs-property">@$el</span>, arguments
        <span class="hljs-attribute">off</span>: <span class="hljs-function"><span class="hljs-params">(name)</span> -&gt;</span>
          name = <span class="hljs-property">@evt</span> name <span class="hljs-keyword">if</span> name?
          <span class="hljs-property">@$el</span>.<span class="hljs-literal">off</span>.apply <span class="hljs-property">@$el</span>, arguments
        <span class="hljs-attribute">trigger</span>: <span class="hljs-function"><span class="hljs-params">(name, userInfo)</span> -&gt;</span>
          type = <span class="hljs-property">@evt</span> name
          <span class="hljs-property">@$el</span>.trigger { type, userInfo }

      <span class="hljs-attribute">selection</span>: <span class="hljs-function">-&gt;</span>
        <span class="hljs-attribute">select</span>: <span class="hljs-function">-&gt;</span>
          <span class="hljs-keyword">for</span> own name, selector <span class="hljs-keyword">of</span> <span class="hljs-property">@selectors</span>
            <span class="hljs-keyword">if</span> (result = <span class="hljs-property">@$el</span>.find selector)?
              @[<span class="hljs-string">"$<span class="hljs-subst">#{name}</span>"</span>] = result
          <span class="hljs-keyword">return</span>
        <span class="hljs-attribute">selectByClass</span>: <span class="hljs-function"><span class="hljs-params">(className)</span> -&gt;</span>
          classNames = <span class="hljs-property">@options</span>?.classNames
          classNames ?= <span class="hljs-property">@classNames</span>
          <span class="hljs-property">@$el</span>.find <span class="hljs-string">".<span class="hljs-subst">#{<span class="hljs-property">@classNames</span>[className]}</span>"</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>ยง <strong>Attaching</strong></p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>_safeSet</strong> is an internal wrapper around <code>_noConflict</code>.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-function">  <span class="hljs-title">_safeSet</span> = <span class="hljs-params">(key, toContext=$, fromContext=hlf)</span> -&gt;</span>
    _oldValue = toContext[key]
    toContext[key] = fromContext[key]
    _noConflicts.push -&gt; toContext[key] = _oldValue
    <span class="hljs-keyword">return</span>

  _safeSet <span class="hljs-string">'applyMixin'</span>
  _safeSet <span class="hljs-string">'applyMixins'</span>
  _safeSet <span class="hljs-string">'createMixin'</span>
  _safeSet <span class="hljs-string">'createPlugin'</span>
  _safeSet <span class="hljs-string">'mixinOnceNames'</span>
  _safeSet <span class="hljs-string">'mixins'</span>

  $.hlf = hlf
)</div></div></div></div></body></html>